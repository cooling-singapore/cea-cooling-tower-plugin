import cea.config
import cea.inputlocator
import cea.plugin
import numpy as np
import pandas as pd
import geopandas as gpd
import csv
import os
import warnings

from itertools import groupby
from cea.utilities import epwreader
from cea.utilities.dbf import dbf_to_dataframe

from cea_heat_rejection_plugin import BASE_CT_THRESHOLD
from cea_heat_rejection_plugin.utilities.DK_thermo import HumidAir
from cea_heat_rejection_plugin.utilities.coolingtowers import set_ambient, simulate_CT, parse_BldgToCTs, calc_CTheatload

CT_CATALOG_FILE = './data/catalog.csv'


class HeatRejectionPlugin(cea.plugin.CeaPlugin):
    """
    Define the plugin class - unless you want to customize the behavior, you only really need to declare the class. The
    rest of the information will be picked up from ``default.config``, ``schemas.yml`` and ``scripts.yml`` by default.
    """
    pass


def get_building_demands(locator):
    building_demands = pd.DataFrame()

    for building_name in locator.get_zone_building_names():
        building_demand = pd.read_csv(locator.get_demand_results_file(building_name))
        cooling_demand = building_demand['DC_cs_kWh'].abs() + building_demand['E_cs_kWh'].abs() + building_demand['Qcs_kWh'].abs()  #Assuring heat rejection is positive
        building_demands[building_name] = cooling_demand

    building_demands['time'] = building_demands.index.values
    return building_demands


def get_building_properties(locator):
    zone_geometry_df = gpd.GeoDataFrame.from_file(locator.get_zone_geometry())
    building_properties = zone_geometry_df[['Name', 'height_ag', 'floors_ag']].set_index('Name')
    return building_properties


def get_building_groups(locator):

    # Specifying types of systems within CEA database
    building_supply = dbf_to_dataframe(locator.get_building_supply())
    database_supply = pd.read_excel(locator.get_database_supply_assemblies(),"COOLING")
    cooling_tower_systems = ['SUPPLY_COOLING_AS2', 'SUPPLY_COOLING_AS3', 'SUPPLY_COOLING_AS4']

    # Check if the user included a building group in the inputs folder
    try:
        with open(locator.get_groups()):
            print("Using building groups generated by the user")

    # The building group is created automatically in the inputs folder if not provided by the user
    except IOError:
        print("Buildings groups not informed, CEA will consider individual buildings (unless connected to District Cooling)")

        #Get list of CEA buildings, separated by decentralized or centralized (district cooling) systems
        names_decentralized = []
        names_centralized = []
        building_demand = pd.read_csv(locator.get_total_demand())
        for i,row in building_supply.iterrows():
            # Buildings that have district cooling supply are assigned to a centralized list
            if database_supply.loc[database_supply.code == row.type_cs].scale.values == "DISTRICT":
                names_centralized.append(row.Name)
            # Buildings that have no district cooling supply are assigned to a decentralized list
            else:
                names_decentralized.append(row.Name)

        # Write CEA buildings groups into a group.csv file:
        os.mkdir(locator.get_groups()[:-9], 0o666)
        with open(locator.get_groups(), 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(('Group', 'Buildings'))
            counter =0
            while counter < len(names_decentralized):
                group_name = 'G1' + str(counter).zfill(3)
                writer.writerow((group_name, names_decentralized[counter]))
                counter += 1
            if names_centralized:
                group_name = 'G1' + str(counter).zfill(3)
                writer.writerow((group_name, ",".join(names_centralized)))

    # Separating building groups with and without cooling towers:
    building_groups = pd.read_csv(locator.get_groups())
    print("Building groups: \n",building_groups)
    data_ct = {'Group':[],'Buildings':[]}
    data_no_ct = {'Group': [], 'Buildings': []}
    for i, grouping in building_groups.iterrows():
        supply_system =[]
        building_list = grouping.Buildings.split(",")
        for building in building_list:
            building_supply_system = building_supply.loc[building_supply.Name == building]
            supply_system.append(building_supply_system.type_cs.values)
        if all(x == supply_system[0] for x in supply_system):
            if supply_system[0] in cooling_tower_systems:
                data_ct['Group'].append(grouping.Group)
                data_ct['Buildings'].append(grouping.Buildings)
            else:
                data_no_ct['Group'].append(grouping.Group)
                data_no_ct['Buildings'].append(grouping.Buildings)
        else:
            warnings.warn("Buildings from the same group must have the same supply system. Please check type_cs for"+str(building_list)) #Throw error
    building_groups_ct = pd.DataFrame(data_ct)
    building_groups_no_ct = pd.DataFrame(data_no_ct) #Not currently used (needed to output minisplit results)
    print("Building groups with cooling tower (district cooling included): \n",building_groups_ct)

    return building_groups_ct

def main(config):
    """
    This is the main entry point to your script. Any parameters used by your script must be present in the ``config``
    parameter. The CLI will call this ``main`` function passing in a ``config`` object after adjusting the configuration
    to reflect parameters passed on the command line / user interface

    :param cea.config.Configuration config: The configuration for this script, restricted to the scripts parameters.
    :return: None
    """

    locator = cea.inputlocator.InputLocator(config.scenario, config.plugins)

    # Read CT catalog
    CT_catalog = pd.read_csv(CT_CATALOG_FILE).set_index('CT')

    # Read scenario weather
    weather = epwreader.epw_reader(locator.get_weather_file())
    drybulb_temp = weather['drybulb_C']
    if max(weather['relhum_percent']) > 100:
        warnings.warn("Original weather has relative humidity above 100%. A maximum of 100% will be considered.")
    rel_humidity = np.clip(weather['relhum_percent']/100, 0.0, 1.0) # Make sure values are between 0 and 1 (inclusive)

    air_i, WBT = set_ambient(drybulb_temp, rel_humidity)

    # read the thermal load
    building_demands = get_building_demands(locator)
    building_properties = get_building_properties(locator)
    building_groups = get_building_groups(locator)

    # compute extra properties
    max_load_series = pd.DataFrame({'Max_load_kWh': building_demands.max(0)})
    min_cap_opp = pd.DataFrame({'Min_Cap_opp': building_demands.replace(0, np.NaN).min(0) / building_demands.max(0)})
    building_demands = building_demands.replace(np.NaN, 0.0)
    building_properties = building_properties.merge(max_load_series, left_index=True, right_index=True)
    building_properties = building_properties.merge(min_cap_opp, left_index=True, right_index=True)
    building_properties.head()

    building_demands = pd.concat([building_demands], ignore_index=True)
    building_demands['time'] = building_demands.index.values

    # agreagate thermal loads
    group_demand_dict = {}
    for i, row in building_groups.iterrows():
        building_list = row['Buildings'].split(",")
        demand = np.zeros(building_demands.shape[0])
        for building in building_list:
            demand += building_demands[building].values
        group_demand_dict[row['Group']] = demand
    group_demand_df = pd.DataFrame(group_demand_dict)

    # Size cooling towers per group
    def find_upper_neighbours(value, df, colname):
        exactmatch = df[df[colname] == value]
        if not exactmatch.empty:
            return exactmatch.index
        else:
            lowerneighbour_ind = df[df[colname] < value][colname].idxmax()
            upperneighbour_ind = df[df[colname] > value][colname].idxmin()
            upperneighbour = df[colname][upperneighbour_ind]
            return upperneighbour

    BldgToCTs = {}
    for (group, demand) in group_demand_df.iteritems():
        peak = max(demand)
        average = np.mean(demand.replace(0, np.NaN))
        baseload = BASE_CT_THRESHOLD * peak
        peak_unit_size = peak - average
        intermediate_unit_size = average - baseload
        base_unit_size = baseload

        # checks
        if peak_unit_size > CT_catalog['Capacity [kW]'].min():
            peak_unit_size = find_upper_neighbours(peak_unit_size, CT_catalog, 'Capacity [kW]')
        else:
            peak_unit_size = CT_catalog['Capacity [kW]'].min()

        if intermediate_unit_size > CT_catalog['Capacity [kW]'].min():
            intermediate_unit_size = find_upper_neighbours(intermediate_unit_size, CT_catalog, 'Capacity [kW]')
        else:
            intermediate_unit_size = CT_catalog['Capacity [kW]'].min()

        if base_unit_size > CT_catalog['Capacity [kW]'].min():
            base_unit_size = find_upper_neighbours(base_unit_size, CT_catalog, 'Capacity [kW]')
        else:
            base_unit_size = CT_catalog['Capacity [kW]'].min()

        BldgToCTs[group] = peak_unit_size, intermediate_unit_size, base_unit_size

    # split the load per Cooling tower capacity
    CT_load, results_columns = calc_CTheatload(group_demand_df, BldgToCTs, CT_catalog, t_from=None, t_to=None)


    CT_design = parse_BldgToCTs(BldgToCTs, CT_catalog)
    CT_design['groups'] = results_columns
    CT_design['ID'] = ['CT' + str(x) for x in CT_design.index]

    # simulate
    res = simulate_CT(CT_load, CT_design, air_i, pump_ctrl='Range limit', fan_ctrl=True)
    airflow = res['air flow']
    waterflow = res['water flow']
    HWT = res['HWT']
    waterflow = res['return water flow']
    T_drybulb_out = res['air_o']
    T_drybulb_out.columns = CT_design['ID']

    # Output results
    out = pd.DataFrame()
    for cooling_tower in res['air_o'].columns:
        _list = list()
        for i in range(0, len(air_i)):
            _list.append(HumidAir.sensible_latent_heat_split(air_i[i], res['air_o'][cooling_tower][i]))
        out[cooling_tower] = _list

    print(out)

if __name__ == '__main__':
    main(cea.config.Configuration())
